### Краткий конспект
В JavaScript логические операторы — это `||`, `&&`, `!` и `??`.
Они работают по **короткому замыканию** и **возвращают один из операндов**, а не обязательно `true/false`.

- `A || B` → выбери **первый truthy**.
- `A && B` → выбери **первый falsy**, иначе `B`.
- `A ?? B` → выбери `B` **только если** `A` — `null`/`undefined`.
- `&&=`, `||=`, `??=` → присваивают по тем же правилам, аккуратнее с побочными эффектами

---

## Truthy / Falsy кратко
**Falsy** значения: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`.
Все остальные — **truthy** (включая объекты, массивы, функции, непустые строки, любые числа кроме `0`, `NaN`).

```js
Boolean({})  // true
Boolean([])  // true
Boolean('0') // true
Boolean(0)   // false
```

---

## `||` — логическое ИЛИ (возвращает первый truthy)
- Возвращает **первый truthy** операнд, иначе — **последний**.
- Правая часть вычисляется **только если** левая falsy.

```js
'a' || 'b'        // 'a'
''  || 'fallback' // 'fallback'
0   || 123        // 123
null || undefined // undefined
```

**Паттерн:** выбрать первое «заданное» значение (но учти, что `0`/`""`/`NaN` тоже заменятся!).
```js
const limit = user.limit || 10; // 0 будет заменён на 10 (иногда нежелательно)
```

---

## `&&` — логическое И (возвращает первый falsy)
- Возвращает **первый falsy** операнд, иначе — **последний**.
- Правая часть вычисляется **только если** левая truthy.

```js
1 && 2       // 2
0 && 'x'     // 0
'hi' && null // null
true && {}   // {}
```

**Паттерн:** «выполнить действие, если условие truthy».
```js
isReady && start(); // вызовет start() только если isReady truthy
```

---

## `!` — логическое НЕ
- Приводит к boolean и инвертирует.

```js
!0       // true
!'text'  // false
!!value  // явное приведение к boolean
```

---

## `??` — nullish coalescing (для null/undefined)
- Возвращает правый операнд **только если** левый — `null` или `undefined` (а не любой falsy).
- Короткое замыкание: правая часть вычисляется только при `null`/`undefined` слева.

```js
null ?? 'x'        // 'x'
undefined ?? 'x'   // 'x'
0 ?? 42            // 0      (НЕ заменяет 0)
'' ?? 'empty'      // ''     (НЕ заменяет пустую строку)
```

**Паттерн:** корректный fallback, когда `0`, `''`, `false` — валидные значения.
```js
const limit = user.limit ?? 10; // 0 сохранится как 0
```

⚠️ **Скобки обязательны** при смешивании с `||`/`&&` (иначе синтаксическая ошибка или путаница приоритета):
```js
(a ?? b) || c
(a && b) ?? c
```

---

## Логические присваивания: `&&=`, `||=`, `??=`
Сокращённые формы, **сохраняют семантику короткого замыкания** и оценивают правую часть только при необходимости.

```js
obj.prop ||= createDefault();   // присвоит только если obj.prop falsy
obj.prop &&= obj.prop.trim();   // применит только если truthy
obj.timeout ??= 5000;           // только если null/undefined
```

**Важное отличие от развёрнутых форм:** обращение к целевому свойству происходит **один раз** — это важно при геттерах/проксах/дорогих вычислениях.

```js
// Плохая альтернатива: свойство читается дважды и RHS может вычислиться зря
obj.prop = obj.prop || createDefault();
```

---

## Возвращаемые значения и цепочки
Операторы возвращают **последний вычисленный операнд** — это позволяет строить компактные цепочки выбора:

```js
// Берём первое доступное значение по приоритету
const lang = user.lang || settings.lang || 'en';

// Комбинирование с безопасным доступом
const theme = user?.prefs?.theme ?? 'light';
```

---

## Типовые приёмы

**1) Гард-условия**
```js
if (!user || !user.isActive) return;
// дальше работаем с активным user
```

**2) Отложенные вычисления**
```js
cache[key] ||= expensiveCompute(key); // посчитает один раз
```

**3) Безопасный вызов**
```js
obj && obj.method && obj.method(); // до optional chaining это был стандартный паттерн
obj?.method?.();                   // современный вариант
```

**4) Короткий возврат значения**
```js
function readPort(env) {
  return Number(env.PORT ?? 3000);
}
```

---

## Подводные камни

- `||` заменяет **любые** falsy (`0`, `''`, `NaN`, `false`) → используйте `??`, если `0/''/false` легитимны.
- `&&` может вернуть **не boolean**, что иногда удивляет:
  ```js
  const el = found && document.getElementById('x'); // el будет либо элемент, либо falsey-значение found
  ```
- Не смешивай `??` с `||`/`&&` без скобок — это либо синтаксическая ошибка, либо нечитаемо.
- Приоритет: `!` выше, чем `&&`; `&&` выше, чем `||` и `??`. У `||` и `??` одинаковый приоритет — ставь скобки.

---

