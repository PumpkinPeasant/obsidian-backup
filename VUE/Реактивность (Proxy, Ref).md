### Что такое «реактивность» в Vue

Vue отслеживает чтение зависимостей и реагирует на их изменение:
- при **чтении** свойства — Vue «подписывает» текущий эффект (рендер, вычисляемое свойство, watcher);
- при **записи** — Vue «триггерит» подписчиков и делает **батчинг** обновлений в один «тик»; DOM обновляется асинхронно (`nextTick`).

### Vue 3 (Proxy-движок)
``` js
import { ref, reactive, computed, watch, watchEffect, nextTick } from 'vue'

const count = ref(0) // для примитивов: .value
const user  = reactive({ name: 'Ann', skills: ['JS'] }) // для объектов/массивов

const doubled = computed(() => count.value * 2) // кэшируется

watch(count, (n, o) => { console.log('count:', o, '→', n) }) // целенаправленные побочки
watchEffect(() => { console.log('autorun:', user.name, count.value) }) // авто-подписка по чтениям

async function inc() {
  count.value++
  await nextTick() // DOM точно обновлён
}
```

| API                         | Что это                                               | Когда использовать                                                         | Чтение / запись                          |
| --------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------- |
| `ref(value)`                | Реактивная «коробочка» для значения                   | Примитивы, единичные значения, счётчики, флаги                             | В шаблоне — как есть; в JS — `.value`    |
| `reactive(obj)`             | Глубокий Proxy над объектом/массивом/коллекциями      | Для структур состояния: объекты, массивы, `Map`/`Set`                      | Доступ обычный: `state.user.name`        |
| `toRef(obj,'key')`          | Точечная «ссылка» (`ref`) на поле реактивного объекта | Когда нужно вынести/деструктурировать одно поле и не потерять реактивность | Как `ref`: в JS — `.value`               |
| `computed(getter[,setter])` | Кэшируемое производное значение                       | Форматирование, фильтры, подсчёты                                          | Чтение как значение; с сеттером — запись |
### Управление глубиной и защитой
| API                    | Поведение                                | Когда использовать                                                                 |
| ---------------------- | ---------------------------------------- | ---------------------------------------------------------------------------------- |
| `readonly(obj)`        | Глубоко «только чтение»                  | Защитить пропсы/стейт от мутаций вне модуля                                        |
| `shallowReadonly(obj)` | Только верхний уровень «только чтение»   | Когда верхний слой менять нельзя, но вложенности можно                             |
| `shallowRef(value)`    | Трекинг только идентичности `.value`     | Хранить инстансы (Chart/Map/Editor) или мутировать объект без «глубоких» триггеров |
| `shallowReactive(obj)` | Реактивен только верхний уровень свойств | Очень большие деревья, оптимизация                                                 |
| `markRaw(instance)`    | Исключает объект из реактивности         | Кэш/инстансы сторонних библиотек                                                   |

