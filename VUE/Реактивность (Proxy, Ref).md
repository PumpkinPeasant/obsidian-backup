**Реактивность** - ==это способность системы реагировать на изменение состояния автоматическим обновлением зависимых эффектов (UI, вычислений).==
### Статьи
- [Proxy MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- [Reactivity Fundamentals](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#reactivity-fundamentals)
- [Reactivity in Depth](https://vuejs.org/guide/extras/reactivity-in-depth.html)
- [Основы Vue 3 - Реактивность | YouTube](https://www.youtube.com/watch?v=-G5g7-AvYkc)
## Кратко: Что такое реактивность во Vue

Vue отслеживает чтение зависимостей и реагирует на их изменение:
- при **чтении** свойства — Vue «подписывает» текущий эффект (рендер, вычисляемое свойство, watcher);
- при **записи** — Vue «триггерит» подписчиков и делает **батчинг** обновлений в один «тик»; DOM обновляется асинхронно (`nextTick`).

### Vue 3 (Proxy-движок)
``` js
import { ref, reactive, computed, watch, watchEffect, nextTick } from 'vue'

const count = ref(0) // для примитивов: .value
const user  = reactive({ name: 'Ann', skills: ['JS'] }) // для объектов/массивов

const doubled = computed(() => count.value * 2) // кэшируется

watch(count, (n, o) => { console.log('count:', o, '→', n) }) // целенаправленные побочки
watchEffect(() => { console.log('autorun:', user.name, count.value) }) // авто-подписка по чтениям

async function inc() {
  count.value++
  await nextTick() // DOM точно обновлён
}
```

| API                         | Что это                                               | Когда использовать                                                         | Чтение / запись                          |
| --------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------- |
| `ref(value)`                | Реактивная «коробочка» для значения                   | Примитивы, единичные значения, счётчики, флаги                             | В шаблоне — как есть; в JS — `.value`    |
| `reactive(obj)`             | Глубокий Proxy над объектом/массивом/коллекциями      | Для структур состояния: объекты, массивы, `Map`/`Set`                      | Доступ обычный: `state.user.name`        |
| `toRef(obj,'key')`          | Точечная «ссылка» (`ref`) на поле реактивного объекта | Когда нужно вынести/деструктурировать одно поле и не потерять реактивность | Как `ref`: в JS — `.value`               |
| `computed(getter[,setter])` | Кэшируемое производное значение                       | Форматирование, фильтры, подсчёты                                          | Чтение как значение; с сеттером — запись |
### Управление глубиной и защитой
| API                    | Поведение                                | Когда использовать                                                                 |
| ---------------------- | ---------------------------------------- | ---------------------------------------------------------------------------------- |
| `readonly(obj)`        | Глубоко «только чтение»                  | Защитить пропсы/стейт от мутаций вне модуля                                        |
| `shallowReadonly(obj)` | Только верхний уровень «только чтение»   | Когда верхний слой менять нельзя, но вложенности можно                             |
| `shallowRef(value)`    | Трекинг только идентичности `.value`     | Хранить инстансы (Chart/Map/Editor) или мутировать объект без «глубоких» триггеров |
| `shallowReactive(obj)` | Реактивен только верхний уровень свойств | Очень большие деревья, оптимизация                                                 |
| `markRaw(instance)`    | Исключает объект из реактивности         | Кэш/инстансы сторонних библиотек                                                   |

## Концепт реактивности

В основе современных фреймворков лежит простая идеология: **Состояние (State) первично, а Интерфейс (UI) — подчинен**,. Состояние — это данные, которые меняются со временем (например, значение счетчика), а UI — это лишь их визуальное отражение.

#### Проблема: человеческий фактор

Когда приложение маленькое, легко вручную вызвать функцию обновления экрана после изменения переменной. Однако в «огромном сложном реальном проекте» вероятность того, что разработчик забудет вызвать перерисовку, составляет 100%.

**Пример проблемы (ручное управление):**

```js
let counter = 0;

function renderCounter() {
    document.getElementById('app').innerText = counter;
}

// Изменили состояние
counter++;
// ОШИБКА: Забыли вызвать renderCounter(), пользователь не видит изменений.
```

#### Решение №1: Инкапсуляция (Подход React)

Чтобы решить проблему «забывчивости», данные можно спрятать внутри специальной функции. Вместо прямого изменения переменной разработчик использует предоставленные инструменты (геттеры и сеттеры), где вызов перерисовки уже «зашит» внутри.

**Пример логики (по мотивам `useState` в React):**

``` js
function useCounter() {
    let counter = 0;
    const getCounter = () => counter;
    const setCounter = (val) => {
        counter = val;
        renderCounter(); // Функция перерисовки вызывается автоматически!
    };
    return { getCounter, setCounter };
}

const { getCounter, setCounter } = useCounter();
setCounter(getCounter() + 1); // Интерфейс обновится сам.
```

#### Решение №2: Геттеры и сеттеры (Подход Vue 2)

Реализация Vue 2 была ближе к нативному JavaScript того времени (стандарт ES5). Использовался метод [[Object.defineProperty]], который позволял превратить обычные свойства объекта в «умные» поля с методами `get` и `set`.

**Пример реализации реактивности с get и set:**

``` js
const count = {
  _value: 5,

  get value(){
    return this._value
  },

  set value(val) {
    this._value = val;
    renderCounter()
  }
}
```

**Пример реализации реактивности Vue 2:**

``` js
const counterState = {};
let _val = 0;

Object.defineProperty(counterState, 'value', {
    get() {
        return _val;
    },
    set(newVal) {
        _val = newVal;
        renderCounter(); // Перерисовка срабатывает при любой попытке записи.
    }
});

counterState.value++; // Больше невозможно забыть обновить UI.
```

> [!Error]
> Главный минус заключался в том, что в реализации с `Object.defineProperty` геттеры и сеттеры добавляются на свойства объекта только в момент его инициализации. Если после этого в объект добавлялось **новое поле**, оно не становилось реактивным, так как для него не были заранее созданы механизмы перехвата (геттеры и сеттеры). Система просто «не видела» таких изменений, и интерфейс не обновлялся автоматически.

#### Решение №3: Proxy-объект (Подход Vue 3)

[[Proxy|Proxy-объект]] - это объект-обертка, который позволяет который **перехватывает любые обращения к полям**. `Proxy` перехватывает **все операции доступа к объекту**, что решает проблему реактивности, которая существовала в реализации Vue 2.

**Пример реализации реактивности с Proxy:**

``` js
let count = {
  value: 5
}

const proxy = new Proxy(count, {
  get(target, prop){
    return target[prop]
  },

  set(target, prop, value){
    target[prop] = value;
    return true;
  }
})
```

