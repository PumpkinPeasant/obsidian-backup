[[#Поднятие переменных]]
[[#Поднятие функций]]
[[#Порядок приоритетов при подъеме]]
[[#Поднятие классов]]
[[#Тест]]
##### Поднятие переменных
==**Поднятие переменных (Hoisting) в JavaScript** — это механизм, при котором объявления переменных== (с использованием ключевого слова `var`) =="поднимаются" наверх своего контекста== (функции или глобальной области видимости) до выполнения кода.

**Объявления поднимаются, но не инициализации**  
Только **объявления** переменных поднимаются наверх контекста, а их значения остаются на местах, где они присваиваются в коде.

`str = 'Hoisting'; // Присваиваем значение переменной` 
`console.log(str); // Логируем значение` 
`var str; // Объявляем переменную`

`var str; // Поднятие объявления 
`str = 'Hoisting'; // Присваивание значения` 
`console.log(str); // Выводит "Hoisting"`

Несмотря на то, что переменная `str` объявлена после её использования, код выполняется без ошибок. Это происходит потому, что JavaScript поднимает **объявление** `var str` наверх.

==Поднимаются только переменные, объявленные с помощью `var`==. Переменные, объявленные с помощью `let` и `const`, также поднимаются, но ведут себя иначе [[Глобальная, функциональная и блочная области#*Особенности `let` и `const|(их область видимости ограничена блоком, а не функцией).]] ^3948fb

`console.log(a); // Output: ReferenceError: a is not defined`
`console.log(b); // Output: ReferenceError: b is not defined
`console.log(c); // undefined
`let a = 10;`     
`const b = 20;`
`var c = 30; `     

Когда переменные объявляются с помощью `let` или `const`, они **поднимаются** в память (т.е. их объявления становятся доступными), но они находятся в **временной мертвой зоне** до момента, когда они инициализируются. Любая попытка обратиться к этой переменной вызовет ошибку `ReferenceError`. 

**Temporal Dead Zone** (TDZ) — это концепция в JavaScript, которая описывает поведение переменных, объявленных с использованием `let` и `const`. В частности, она касается периода времени между началом выполнения кода и фактическим объявлением переменной в потоке выполнения.

##### Поднятие функций 
**Объявления функций (Function Declarations)**
Функции, объявленные через **function declaration**, полностью поднимаются. Это означает, что **имя** и **тело функции** поднимаются на верх области видимости. Благодаря этому можно вызвать функцию **до её объявления** в коде.

`hoisted(); // Вывод: "Hello World!."  
`function hoisted() {`   
`console.log('Hello World!');` 
`}`

**Функциональные выражения (Function Expressions)**
В случае функциональных выражений поднимается **только объявление переменной**, но не присваивание функции этой переменной.

`expression(); // Вывод: "TypeError: expression is not a function"` 
`var expression = function() {` 
	`console.log('Will this work?');` 
`};`

В этом случае объявление переменной `expression` поднимется, но присваивание ей функции произойдёт позже, уже в момент выполнения кода.

**Комбинированное использование объявления функции и функционального выражения**

`expression(); // Вывод: TypeError: expression is not a function` 
`var expression = function hoisting() {` 
	`console.log('Will this work?');` 
`};`

В данном примере переменная `expression` поднимется, но присваивание ей функции будет выполнено позже. Когда интерпретатор видит строку `expression()`, переменная еще не инициализирована функцией, а поэтому при вызове она имеет значение `undefined`, что вызывает ошибку `TypeError`.

**Функции с присваиванием через `const` и `let`**
Если мы используем `const` или `let` для объявления переменной с анонимной функцией, то при попытке вызова функции до её присваивания возникнет ошибка **`ReferenceError`**, потому что переменная будет находиться в **временной мертвой зоне** до инициализации.

`myFunction(); // ReferenceError: Cannot access 'myFunction' before initialization` 
`const myFunction = function() {` 
	`console.log("I am an anonymous function!");` 
`};`

##### Порядок приоритетов при подъеме
**Присваивание переменной имеет больший приоритет, чем объявление функции**. Если переменная и функция имеют одинаковое имя, то **присваивание переменной** имеет больший приоритет, и функция будет проигнорирована.

`var double = 22;` 
`function double(num) {` 
	`return num * 2;` 
`}` 
`console.log(typeof double); // Вывод: "number"`

**Объявления функции имеют больший приоритет, чем объявления переменной**. Если в коде есть и объявление функции, и переменная с одинаковым именем, то **объявление функции** будет иметь больший приоритет.

`var double;` 
`function double(num) {` 
	`return num * 2;` 
`}` 
`console.log(typeof double); // Вывод: "function"`

##### Поднятие классов
**Классовые декларации (Class Declarations)**
Классовые декларации поднимаются, но ведут себя иначе, чем обычные функции или переменные. Хотя сам класс поднимается в коде, **он остается неинициализированным** до момента выполнения строки, в которой объявление класса фактически выполняется.

`var Frodo = new Hobbit(); // Ошибка: ReferenceError: Hobbit is not defined` 
`class Hobbit {` 
	`constructor(height, weight) {` 
		`this.height = height;` 
		`this.weight = weight;` 
	`}` 
`}`

Несмотря на то, что класс `Hobbit` объявляется с помощью `class`, он **поднимется**, но останется **неинициализированным** до того, как будет выполнена строка с его реальной декларацией. Поэтому попытка создать экземпляр `Hobbit` до его объявления вызовет ошибку `ReferenceError`.

**Классовые выражения (Class Expressions)**
Классовые выражения ведут себя аналогично функциям и **не поднимаются** в том смысле, что они не могут быть использованы до их инициализации. Это означает, что попытка использовать класс, объявленный как выражение, до его объявления приведет к ошибке.

`var Square = new Polygon(); // Ошибка: TypeError: Polygon is not a constructor` 
`var Polygon = class {` 
	`constructor(height, width) {` 
		`this.height = height;` 
		`this.width = width;` 
	`}` 
`};`

Интерпретатор будет воспринимать `Polygon` как обычную переменную, а не как функцию-конструктор.

##### Тест
https://www.w3schools.com/js/js_hoisting.asp
