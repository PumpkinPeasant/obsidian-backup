Эти методы позволяют **управлять значением `this`** при вызове функций и передавать аргументы.

---
### **`call()`**

**Синтаксис:**
``` js
  jsfunc.call(thisArg, arg1, arg2, ...)
  	```

 **Что делает:** вызывает функцию немедленно, передавая `thisArg` как контекст и аргументы через запятую.
 
 **Пример:**
``` js
    function greet(greeting, name) {   
	    console.log(`${greeting}, ${name}! Я – ${this.role}`); 
    }  
    const obj = { role: 'админ' }; 
    greet.call(obj, 'Привет', 'Аня');  // Привет, Аня! Я – админ
    ```

---

### **`apply()`**

**Синтаксис:**
``` js
func.apply(thisArg, [argsArray])
```

**Что делает:** аналог `call()`, но аргументы передаются **массивом**.

**Пример:**
``` js
greet.apply(obj, ['Здравствуйте', 'Иван']); // Здравствуйте, Иван! Я – админ
```

---

### **`bind()`**

**Синтаксис:**
``` js
    const newFunc = func.bind(thisArg, arg1, arg2, ...)
    ```

**Что делает:** возвращает **новую функцию** с привязанным `this` и (опционально) частично переданными аргументами. **Не вызывает сразу**

**Пример:**
``` js
const greetAdmin = greet.bind(obj, 'Привет'); greetAdmin('Мария');  // Привет, Мария! Я – админ
    ```

---

### **Ключевые отличия**

- `call` – вызов с аргументами через запятую.
- `apply` – вызов с аргументами массивом.
- `bind` – не вызывает, а создаёт новую функцию с фиксированным контекстом.

---

### Когда использовать
- **`call` и `apply`**: когда нужно **сразу вызвать** функцию с определённым `this`.
- **`apply`** удобно применять, когда аргументы уже есть в виде массива (например, `Math.max.apply(null, arr)`).
- **`bind`**: для передачи методов как колбэков без потери контекста, или частичного применения аргументов (каррирование).