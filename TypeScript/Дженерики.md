Поскольку часто нужны функции и классы, которые **гибкие, но типобезопасные**, в **TypeScript** ввели **Generics (дженерики)**.

Это возможность писать обобщённый код, где вместо конкретного типа указывается параметр типа.  
Таким образом одна функция может работать с разными типами, но при этом сохранять типовую информацию.

---

### Пример 1: обобщённая функция

`function identity<T>(value: T): T {   return value; }  let num = identity<number>(5);    // num: number let str = identity<string>("hi"); // str: string`

Здесь:

- `T` — это **параметр типа** (можно назвать хоть `Type`, `X`, `U`, но обычно `T`).
    
- Когда мы вызываем `identity<number>(5)`, мы подставляем `T = number`.
    
- TypeScript проверяет: вход — число, выход — тоже число.
    

---

### Пример 2: массивы

`function getFirstElement<T>(arr: T[]): T | undefined {   return arr[0]; }  let a = getFirstElement([1, 2, 3]);       // a: number let b = getFirstElement(["a", "b", "c"]); // b: string`

---

### Пример 3: несколько параметров типа

`function merge<T, U>(a: T, b: U): [T, U] {   return [a, b]; }  let result = merge<string, number>("id", 42);  // result: [string, number]`

---

### Пример 4: ограничения (extends)

Можно ограничить тип параметра:

`function lengthOf<T extends { length: number }>(arg: T): number {   return arg.length; }  lengthOf("hello");   // 5 lengthOf([1, 2, 3]); // 3 // lengthOf(42); ❌ ошибка — у числа нет length`

---

### Пример 5: дженерики в классах

`class Box<T> {   private content: T;   constructor(value: T) {     this.content = value;   }   getValue(): T {     return this.content;   } }  let numberBox = new Box<number>(123); let stringBox = new Box<string>("hello");`

---

## 3. Синтаксис (обобщённо)

- **Функции**:
    
    `function funcName<T>(arg: T): T { ... }`
    
- **Классы**:
    
    `class ClassName<T> { ... }`
    
- **Интерфейсы**:
    
    `interface ApiResponse<T> {   data: T;   error?: string; }`
    
- **Ограничения**:
    
    `function foo<T extends SomeType>(arg: T) { ... }`